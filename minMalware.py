"""
Use Union-Find (Disjoint Set Union) to group all connected components
For each component, count its size and how many infected nodes it has
The best node to remove is the only infected node in a component with the largest size
"""
"""
Time Complexity: O(n^2)	For adjacency matrix + union-find
Space Complexity: O(n)	For parent, size, and count arrays
"""

class minMalware:
    def minMalwareSpread(self, graph: list[list[int]], initial: list[int]) -> int:
        n = len(graph)
        parent = [i for i in range(n)]

        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        def union(x, y):
            rootX, rootY = find(x), find(y)
            if rootX != rootY:
                parent[rootY] = rootX


        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1:
                    union(i, j)


        size = [0] * n
        for i in range(n):
            size[find(i)] += 1

        malware_count = [0] * n
        for node in initial:
            malware_count[find(node)] += 1

        result = float('inf')
        max_saved = -1

        for node in sorted(initial): 
            root = find(node)
            if malware_count[root] == 1:  
                if size[root] > max_saved:
                    max_saved = size[root]
                    result = node

        return result if result != float('inf') else min(initial)

if __name__ == "__main__":
    obj = minMalware()
    print(obj.minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]))  
    print(obj.minMalwareSpread([[1,0,0],[0,1,0],[0,0,1]], [0,2])) 
    print(obj.minMalwareSpread([[1,1,1],[1,1,1],[1,1,1]], [1,2])) 
